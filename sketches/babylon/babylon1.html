<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Babylon 1</title>

  <style>
    html, body {
      overflow: hidden;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
    }
  </style>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>

</head>

<body>

<canvas id="renderCanvas"></canvas>

<script>
  const canvas = document.getElementById("renderCanvas"); // Get the canvas element
  const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

  const createScene = function () {
    console.log("create scene");

    // This creates a basic Babylon Scene object (non-mesh)
    const scene = new BABYLON.Scene(engine);

    var crateTex = new BABYLON.Texture("../textures/crate1_diffuse.png",scene);
    console.log(crateTex);
    // This creates and positions a free camera (non-mesh)
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    // This targets the camera to scene origin
    camera.setTarget(BABYLON.Vector3.Zero());
    // This attaches the camera to the canvas
    camera.attachControl(canvas, true);
    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 0.7;
    // Our built-in 'sphere' shape.
    const cube = BABYLON.MeshBuilder.CreateBox("cube", {diameter: 2, segments: 32}, scene);
    var crateMat = new BABYLON.StandardMaterial("crateMat");
    crateMat.diffuseTexture = crateTex;

    cube.material = crateMat;


    cube.updateFacetData();
    // Move the sphere upward 1/2 its height
    cube.position.y = 1;
    // Our built-in 'ground' shape.
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, scene);
    ground.material = crateMat;
    ground.updateFacetData();

    const marker = BABYLON.MeshBuilder.CreateSphere("marker",{diameter :0.1 },scene);
    var mat = new BABYLON.StandardMaterial("mat", scene);
    mat.diffuseColor = new BABYLON.Color3(1,0,0);
    marker.material = mat;

    var uv = {};



    // GUI
    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
    var loadedGUI = advancedTexture.parseFromURLAsync("./guiTexture.json");
    function rayFilter(mesh) {
      if (mesh == marker) {
        return false;
      }
      return true;
    }
    function castRay()
    {
      pointGUI = advancedTexture.getControlByName("Point");



      var ray = scene.createPickingRay(scene.pointerX,scene.pointerY,BABYLON.Matrix.Identity(),camera);
      var pickResult = scene.pickWithRay(ray,rayFilter);

      if (pickResult.hit) {
        var p = pickResult.pickedPoint;
        if(marker)
        {
          marker.position = p;
        }
        uv = pickResult.getTextureCoordinates();
        var facetIndex = pickResult.pickedMesh.getClosestFacetAtCoordinates(p.x, p.y, p.z);

        console.log("u: "+uv.x.toFixed(4)+" y:"+uv.y.toFixed(4))
        // header.text = "u: "+uv.x.toFixed(4)+" y:"+uv.y.toFixed(4);
        if(pointGUI){
          pointGUI.left =  uv.x * 200 - 100;
          pointGUI.top = -uv.y * 200 + 100;
          console.log(pointGUI);
        }else{
          console.log("WHY NULL!?!?");
        }

        if (facetIndex == null) {
          return;
        }

        var normal = pickResult.pickedMesh.getFacetNormal(facetIndex);     // its normal (Vector3)
        var position = pickResult.pickedMesh.getFacetPosition(facetIndex);  // its barycenter position in the local space (Vector3)

        // console.log("data:" + cube);
      }
    }

    var alpha = 0;
    scene.onBeforeRenderObservable.add(function () {
      cube.rotation.y = Math.cos(alpha)*2;
      castRay();
      alpha += 0.01;
    });

    return scene;
  };
  const scene = createScene(); //Call the createScene function

  // Register a render loop to repeatedly render the scene
  engine.runRenderLoop(function () {
      scene.render();

  });

  function getForwardVector(_mesh) {

    _mesh.computeWorldMatrix(true);
    var forward_local = new BABYLON.Vector3(0, 0, 1);
    worldMatrix = _mesh.getWorldMatrix();
    return BABYLON.Vector3.TransformNormal(forward_local, worldMatrix);
  }

  // Watch for browser/canvas resize events
  window.addEventListener("resize", function () {
    engine.resize();
  });
</script>

</body>

</html>
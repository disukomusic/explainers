<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Perspective Distortion</title>
  <link rel="stylesheet" href="../shared/css/cutestrap.min.css">
  <script src="/shared/js/three.js"></script>
  <style>
    .slidecontainer{
      width: 100%;
    }
    .slider {
      -webkit-appearance: none;
      width: 658px;
      height: 0;
      border-radius: 5px;
      background: #d3d3d3;
      outline: none;
      opacity: 0.7;
      -webkit-transition: .2s;
      transition: opacity .2s;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 35px;
      height: 35px;
      border-radius: 100%;
      background: #444444;
      cursor: pointer;
    }

    .slider::-moz-range-thumb {
      width: 40px;
      height: 40px;
      border-radius: 100%;
      background: #444444;
      cursor: pointer;
    }
  </style>

</head>
<body>
<article class="wrapper -thin">
  <h1>Perspective Distortion</h1>
  <p>Perspective, or why lenses don't compress things.</p>
  <hr />
  <h3>Prelude: The Hitchcock Zoom</h3>
  <p>The <a href="https://en.wikipedia.org/wiki/Dolly_zoom" target="_blank">Hitchcock zoom</a>, or dolly zoom, is a famous little bit of optical trickery from the world of cinema. If you can unlock how this trick works, then you have an understanding of perspective distortion.</p>
  <p>So, before we get into exploring perspective distortion, take a look at this montage video of some famous shots that manipulate perspective.</p>
  <p>There is no CGI or such trickery, this effect is done in-camera, and the underlying concepts that power this trick are used by photographers every single time we take a photo.</p>
  <p>The short version is this: instead of animating along the effect, a photographer has the ability to choose how to stage the scene in terms of "compression", the effect being demonstrated in the dolly zoom.</p>
  <p>A photographer might think with questions like the following:</p>
  <ul>
    <li>How 'far away' should the background be?</li>
    <li>How close to the same size should objects be?</li>
    <li>How much larger should our subject be than the background?</li>
  </ul>
  <iframe src="https://player.vimeo.com/video/84548119?h=38cd1e037a&color=ffeb14&portrait=0" width="688" height="400" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe>
  <p><a href="https://vimeo.com/84548119">Evolution of the Dolly Zoom</a> from <a href="https://vimeo.com/vashi">Vashi Nedomansky ACE</a> on <a href="https://vimeo.com">Vimeo</a>.</p>
  <hr />
  <h3>Zoom Is Just Crop</h3>
  <p>All zooming in and out of our image does is crop it.</p>
  <p>Zooming in on and image and cropping after the fact will produce images that (aside from resolution or sharpness) look the same. Objects will be positioned in the 2D frame similarly.</p>
  <p>The only thing that changes the relative sizes of objects is distance.</p>
  <p>Explore the toy below. Change the distance such that two objects are aligned in the 2D final camera image. Then adjusting the field of view (FOV) (AKA zooming in or out). Note how the alignment doesn't change.</p>
  <canvas id="demo1" width="688px" height="400px"></canvas>
  <div class="slidecontainer">

    <label for="fovSlider">fov (zoom)</label>
    <input type="range" min="05" max="180" value="50" class="slider" id="fovSlider">
    <label for="dollySlider">distance (position)</label>
    <input type="range" min="0" max="100" value="50" class="slider" id="dollySlider">
  </div>
</article>

<script>
  var fovSlide = document.getElementById("fovSlider");
  var dollSlide = document.getElementById("dollySlider");


  var scene = new THREE.Scene();
  var camera = new THREE.PerspectiveCamera(90, 688 / 400, 0.1, 1000);

  //var renderer = new THREE.WebGLRenderer();
  var renderer = new THREE.WebGLRenderer( { canvas: demo1 } );
  renderer.setSize(688, 400);
  //document.body.appendChild(renderer.domElement);

  const geometry = new THREE.BoxGeometry( 1, 1, 1 );
  const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 , wireframe: true }  );
  const cube = new THREE.Mesh( geometry, material );
  scene.add( cube );

  const geometry2 = new THREE.BoxGeometry( 1, 1, 1 );
  const material2 = new THREE.MeshBasicMaterial( { color: 0xff0000 , wireframe: true } );
  const cube2 = new THREE.Mesh( geometry2, material2 );
  cube2.position.x = -2
  cube2.position.z = 2;
  scene.add( cube2 );

  const geometry3 = new THREE.BoxGeometry( 1, 1, 1 );
  const material3 = new THREE.MeshBasicMaterial( { color: 0x0000ff , wireframe: true }  );
  const cube3 = new THREE.Mesh( geometry3, material3 );
  cube3.position.x = 2;
  cube2.position.z = -2;

  const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 10 , 10 ), new THREE.MeshBasicMaterial( { color: 0x999999, wireframe: true } ) );
  mesh.rotation.x = - Math.PI / 2;
  mesh.receiveShadow = true;
  mesh.position.y = -0.5;
  scene.add( mesh );

  scene.add( cube3 );

  camera.position.z = dollSlide.value;
  var render = function() {
    requestAnimationFrame(render);
    camera.fov = fovSlide.value;
    camera.updateProjectionMatrix();
    camera.position.z = dollSlide.value/10 + 0.61;//+6 to stay outside of cube at 0,0,0
    renderer.render(scene, camera);
  };

  render();

  // Update the current slider value (each time you drag the slider handle)
  fovSlide.oninput = function() {
    camera.fov = this.value;
    // render();
  }
</script>
</body>
</html>
